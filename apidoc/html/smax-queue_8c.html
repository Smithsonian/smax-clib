<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>smax-clib: src/smax-queue.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="smithsonian-logo-55x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">smax-clib
   &#160;<span id="projectnumber">v0.9</span>
   </div>
   <div id="projectbrief">A C/C++ client library for SMA-X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('smax-queue_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">smax-queue.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to support pipelined pull requests from SMA-X. Because they don't requite a sequence of round-trips, pipelined pulls can be orders of magnitude faster than staggered regular pull requests.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae68cb43ec0685e01b01d74f8469ebda2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXSyncPoint.html">XSyncPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smax-queue_8c.html#ae68cb43ec0685e01b01d74f8469ebda2">smaxCreateSyncPoint</a> ()</td></tr>
<tr class="separator:ae68cb43ec0685e01b01d74f8469ebda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012860edbebf45f24b1b08c02a37847b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smax-queue_8c.html#a012860edbebf45f24b1b08c02a37847b">smaxDestroySyncPoint</a> (<a class="el" href="structXSyncPoint.html">XSyncPoint</a> *s)</td></tr>
<tr class="separator:a012860edbebf45f24b1b08c02a37847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c71427a215e2253d93de24788db338d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smax-queue_8c.html#a2c71427a215e2253d93de24788db338d">smaxQueue</a> (const char *table, const char *key, XType type, int count, void *value, <a class="el" href="structXMeta.html">XMeta</a> *meta)</td></tr>
<tr class="separator:a2c71427a215e2253d93de24788db338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06781e13ee30b0530ba3ed2e4436b449"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smax-queue_8c.html#a06781e13ee30b0530ba3ed2e4436b449">smaxQueueCallback</a> (void(*f)(void *), void *arg)</td></tr>
<tr class="separator:a06781e13ee30b0530ba3ed2e4436b449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7ff182bf54594d796d52e7d6a1a41d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smax-queue_8c.html#a7b7ff182bf54594d796d52e7d6a1a41d">smaxSetMaxPendingPulls</a> (int n)</td></tr>
<tr class="separator:a7b7ff182bf54594d796d52e7d6a1a41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a901b9e649c77d29379b8fc31cbefc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smax-queue_8c.html#a90a901b9e649c77d29379b8fc31cbefc">smaxSync</a> (<a class="el" href="structXSyncPoint.html">XSyncPoint</a> *sync, int timeoutMillis)</td></tr>
<tr class="separator:a90a901b9e649c77d29379b8fc31cbefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065361085eed93188b7fd3ffe3a7eaf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smax-queue_8c.html#a065361085eed93188b7fd3ffe3a7eaf5">smaxWaitQueueComplete</a> (int timeoutMillis)</td></tr>
<tr class="separator:a065361085eed93188b7fd3ffe3a7eaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to support pipelined pull requests from SMA-X. Because they don't requite a sequence of round-trips, pipelined pulls can be orders of magnitude faster than staggered regular pull requests. </p>
<dl class="section date"><dt>Date</dt><dd>Jun 25, 2019 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Attila Kovacs </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae68cb43ec0685e01b01d74f8469ebda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68cb43ec0685e01b01d74f8469ebda2">&#9670;&nbsp;</a></span>smaxCreateSyncPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXSyncPoint.html">XSyncPoint</a>* smaxCreateSyncPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a synchronization point that can be waited upon until all elements queued prior to creation are processed (retrieved from the database.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a newly created synchronization point that can be waited upon.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="smax-queue_8c.html#a90a901b9e649c77d29379b8fc31cbefc">smaxSync()</a> </dd>
<dd>
<a class="el" href="smax-queue_8c.html#a2c71427a215e2253d93de24788db338d">smaxQueue()</a> </dd>
<dd>
<a class="el" href="smax-queue_8c.html#a06781e13ee30b0530ba3ed2e4436b449">smaxQueueCallback()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXSyncPoint.html#a0b9f91194934aba0d7936d18d4bc81cc">XSyncPoint::isComplete</a>, and <a class="el" href="structXSyncPoint.html#a33586b4184d23f2b8f4df153ec23af13">XSyncPoint::lock</a>.</p>

</div>
</div>
<a id="a012860edbebf45f24b1b08c02a37847b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012860edbebf45f24b1b08c02a37847b">&#9670;&nbsp;</a></span>smaxDestroySyncPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smaxDestroySyncPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXSyncPoint.html">XSyncPoint</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a synchronization point, releasing the memory space allocated to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the synchronization point to discard. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structXSyncPoint.html#a0b9f91194934aba0d7936d18d4bc81cc">XSyncPoint::isComplete</a>, and <a class="el" href="structXSyncPoint.html#a33586b4184d23f2b8f4df153ec23af13">XSyncPoint::lock</a>.</p>

</div>
</div>
<a id="a2c71427a215e2253d93de24788db338d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c71427a215e2253d93de24788db338d">&#9670;&nbsp;</a></span>smaxQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smaxQueue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXMeta.html">XMeta</a> *&#160;</td>
          <td class="paramname"><em>meta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queues a pull requests for pipelined data retrieval. Because pipelined pulls are executed on a separate Redis client from the one used for sharing values, e.g. via <a class="el" href="smax_8c.html#aee07f085e12283ad96f42c4d77430880">smaxShare()</a>, there is no guarantee as to the order of this pull operation and previously initiated shares from the same thread. This would only be an issue if you are trying to use queued read to read back a value you have just shared &ndash; which is not really a good use case anyway, as it generates network traffic for not real reason. But, if you must read back a value you have shared, you probably should use a regular <a class="el" href="smax_8c.html#afb7eec789669c3d3f416857d3615ace6">smaxPull()</a> call to ensure ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Hash table name. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>Variable name under which the data is stored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>SMA-X variable type, e.g. X_FLOAT or X_CHARS(40), of the buffer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>Number of points to retrieve into the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Pointer to the buffer to which the data is to be retrieved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meta</td><td>Pointer to the corresponding metadata structure, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if successful X_NAME_INVALID if the table and key are both NULL X_NULL if the value field is NULL or the return value of xQueue().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="smax_8c.html#afb7eec789669c3d3f416857d3615ace6">smaxPull()</a> </dd>
<dd>
<a class="el" href="smax-lazy_8c.html#ab50222d7bbaa985fd6d004d67b0269ce">smaxLazyPull()</a> </dd>
<dd>
<a class="el" href="smax-queue_8c.html#ae68cb43ec0685e01b01d74f8469ebda2">smaxCreateSyncPoint()</a> </dd>
<dd>
<a class="el" href="smax-queue_8c.html#a06781e13ee30b0530ba3ed2e4436b449">smaxQueueCallback()</a> </dd></dl>

</div>
</div>
<a id="a06781e13ee30b0530ba3ed2e4436b449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06781e13ee30b0530ba3ed2e4436b449">&#9670;&nbsp;</a></span>smaxQueueCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smaxQueueCallback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a callback function to the queue to be called with the specified argument once all prior requests in the queue have been fullfilled (retrieved from the database).</p>
<p>As a general rule callbacks added to the pipeline should return very fast, and avoid blocking operations for the most part (using mutexes that may block for very short periods only may be excepted). If the user needs to do more processing, or make blocking calls (e.g. IO operartions) that may not return for longer periods, the callback should fire off processing in a separate thread, or else simply move the result into another asynchronous processing queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The callback function that takes a pointer argument </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to call the specified function with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) or else X_NULL if the function parameter is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="smax-queue_8c.html#ae68cb43ec0685e01b01d74f8469ebda2">smaxCreateSyncPoint()</a> </dd>
<dd>
<a class="el" href="smax-queue_8c.html#a2c71427a215e2253d93de24788db338d">smaxQueue()</a> </dd></dl>

</div>
</div>
<a id="a7b7ff182bf54594d796d52e7d6a1a41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7ff182bf54594d796d52e7d6a1a41d">&#9670;&nbsp;</a></span>smaxSetMaxPendingPulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smaxSetMaxPendingPulls </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures how many pull requests can be queued in when piped pulls are enabled. If the queue reaches the specified limit, no new pull requests can be submitted until responses arrive, draining the queue somewhat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The maximum number of pull requests that can be queued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the argument was valid, and the queue size was set to it, otherwise FALSE </dd></dl>

</div>
</div>
<a id="a90a901b9e649c77d29379b8fc31cbefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a901b9e649c77d29379b8fc31cbefc">&#9670;&nbsp;</a></span>smaxSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smaxSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXSyncPoint.html">XSyncPoint</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for the queue to reach the specified sync point, up to an optional timeout limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>Pointer to a queued synchronization point. </td></tr>
    <tr><td class="paramname">timeoutMillis</td><td>An optional timeout in milliseconds. When set to a positive value The call will be guaranteed to return in the specified interval, whether or not the pipelined reads all succeeded. The return value can be used to check for errors or if the call timed out before all data were collected. If X_TIMEDOUT is returned, smax_end_bulk_pulls() may be called again to allow more time for the queued read operations to complete. 0 or negative timeout values will cause the call to wait indefinitely until reads are complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if all reads have completed successfully, or the first read error that was enountered (e.g. RM_INVALID_KEY), or: X_TIMEDOUT if the call timed out while still awaiting data for the queued read requests. X_NULL if the SyncPoint argument is NULL, or its mutex/condition field have not been initialized. X_FAILURE if the SyncPoint's mutex has not been initialized.</dd></dl>
<p>or the first pull error encountered in the queue since the current batch began.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="smax-queue_8c.html#ae68cb43ec0685e01b01d74f8469ebda2">smaxCreateSyncPoint()</a> </dd>
<dd>
<a class="el" href="smax-queue_8c.html#a065361085eed93188b7fd3ffe3a7eaf5">smaxWaitQueueComplete()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXSyncPoint.html#a0b9f91194934aba0d7936d18d4bc81cc">XSyncPoint::isComplete</a>, <a class="el" href="structXSyncPoint.html#a33586b4184d23f2b8f4df153ec23af13">XSyncPoint::lock</a>, and <a class="el" href="structXSyncPoint.html#a6e27f49150e9a14580fb313cc2777e00">XSyncPoint::status</a>.</p>

</div>
</div>
<a id="a065361085eed93188b7fd3ffe3a7eaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065361085eed93188b7fd3ffe3a7eaf5">&#9670;&nbsp;</a></span>smaxWaitQueueComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smaxWaitQueueComplete </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMillis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until all queued pull requests have been retrieved from the database, or until the specified timeout it reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutMillis</td><td>An optional timeout in milliseconds. When set to a positive value The call will be guaranteed to return in the specified interval, whether or not the pipelined reads all succeeded. The return value can be used to check for errors or if the call timed out before all data were collected. If X_TIMEDOUT is returned, smax_end_bulk_pulls() may be called again to allow more time for the queued read operations to complete. 0 or negative timeout values will cause the call to wait indefinitely until reads are complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if all reads have completed successfully, or the first read error that was enountered (e.g. RM_INVALID_KEY), or: X_TIMEDOUT if the call timed out while still awaiting data for the queued read requests.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="smax-queue_8c.html#a90a901b9e649c77d29379b8fc31cbefc">smaxSync()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="smax-queue_8c.html">smax-queue.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
