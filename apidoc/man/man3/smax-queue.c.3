.TH "src/smax-queue.c" 3 "Version v0.9" "smax-clib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/smax-queue.c \- Functions to support pipelined pull requests from SMA-X\&. Because they don't requite a sequence of round-trips, pipelined pulls can be orders of magnitude faster than staggered regular pull requests\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBXSyncPoint\fP * \fBsmaxCreateSyncPoint\fP ()"
.br
.ti -1c
.RI "void \fBsmaxDestroySyncPoint\fP (\fBXSyncPoint\fP *s)"
.br
.ti -1c
.RI "int \fBsmaxQueue\fP (const char *table, const char *key, \fBXType\fP type, int count, void *value, \fBXMeta\fP *meta)"
.br
.ti -1c
.RI "int \fBsmaxQueueCallback\fP (void(*f)(void *), void *arg)"
.br
.ti -1c
.RI "int \fBsmaxSetMaxPendingPulls\fP (int n)"
.br
.ti -1c
.RI "int \fBsmaxSync\fP (\fBXSyncPoint\fP *sync, int timeoutMillis)"
.br
.ti -1c
.RI "int \fBsmaxWaitQueueComplete\fP (int timeoutMillis)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Functions to support pipelined pull requests from SMA-X\&. Because they don't requite a sequence of round-trips, pipelined pulls can be orders of magnitude faster than staggered regular pull requests\&. 


.PP
\fBDate\fP
.RS 4
Jun 25, 2019 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "\fBXSyncPoint\fP * smaxCreateSyncPoint ()"
Creates a synchronization point that can be waited upon until all elements queued prior to creation are processed (retrieved from the database\&.
.PP
\fBReturns\fP
.RS 4
Pointer to a newly created synchronization point that can be waited upon\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBsmaxSync()\fP 
.PP
\fBsmaxQueue()\fP 
.PP
\fBsmaxQueueCallback()\fP 
.RE
.PP

.PP
References \fBXSyncPoint::isComplete\fP, \fBXSyncPoint::lock\fP, \fBXSyncPoint::status\fP, \fBX_INCOMPLETE\fP, and \fBX_SUCCESS\fP\&.
.SS "void smaxDestroySyncPoint (\fBXSyncPoint\fP * s)"
Destroys a synchronization point, releasing the memory space allocated to it\&.
.PP
\fBParameters\fP
.RS 4
\fIs\fP Pointer to the synchronization point to discard\&. 
.RE
.PP

.PP
References \fBXSyncPoint::isComplete\fP, and \fBXSyncPoint::lock\fP\&.
.SS "int smaxQueue (const char * table, const char * key, \fBXType\fP type, int count, void * value, \fBXMeta\fP * meta)"
Queues a pull requests for pipelined data retrieval\&. Because pipelined pulls are executed on a separate \fBRedis\fP client from the one used for sharing values, e\&.g\&. via \fBsmaxShare()\fP, there is no guarantee as to the order of this pull operation and previously initiated shares from the same thread\&. This would only be an issue if you are trying to use queued read to read back a value you have just shared -- which is not really a good use case anyway, as it generates network traffic for not real reason\&. But, if you must read back a value you have shared, you probably should use a regular \fBsmaxPull()\fP call to ensure ordering\&.
.PP
\fBParameters\fP
.RS 4
\fItable\fP Hash table name\&. 
.br
\fIkey\fP Variable name under which the data is stored\&. 
.br
\fItype\fP SMA-X variable type, e\&.g\&. X_FLOAT or \fBX_CHARS(40)\fP, of the buffer\&. 
.br
\fIcount\fP Number of points to retrieve into the buffer\&. 
.br
\fIvalue\fP Pointer to the buffer to which the data is to be retrieved\&. 
.br
\fImeta\fP Pointer to the corresponding metadata structure, or NULL\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful X_NAME_INVALID if the table and key are both NULL X_NULL if the value field is NULL or the return value of xQueue()\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBsmaxPull()\fP 
.PP
\fBsmaxLazyPull()\fP 
.PP
\fBsmaxCreateSyncPoint()\fP 
.PP
\fBsmaxQueueCallback()\fP 
.RE
.PP

.PP
References \fBREDISX_PIPELINE_CHANNEL\fP, \fBSMAX_PIPE_READ_TIMEOUT_MILLIS\fP, \fBx_error()\fP, \fBX_GROUP_INVALID\fP, \fBX_NAME_INVALID\fP, \fBX_NO_SERVICE\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, \fBx_trace()\fP, and \fBxStringCopyOf()\fP\&.
.SS "int smaxQueueCallback (void(*)(void *) f, void * arg)"
Adds a callback function to the queue to be called with the specified argument once all prior requests in the queue have been fullfilled (retrieved from the database)\&.
.PP
As a general rule callbacks added to the pipeline should return very fast, and avoid blocking operations for the most part (using mutexes that may block for very short periods only may be excepted)\&. If the user needs to do more processing, or make blocking calls (e\&.g\&. IO operartions) that may not return for longer periods, the callback should fire off processing in a separate thread, or else simply move the result into another asynchronous processing queue\&.
.PP
\fBParameters\fP
.RS 4
\fIf\fP The callback function that takes a pointer argument 
.br
\fIarg\fP Argument to call the specified function with\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) or else X_NULL if the function parameter is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBsmaxCreateSyncPoint()\fP 
.PP
\fBsmaxQueue()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int smaxSetMaxPendingPulls (int n)"
Configures how many pull requests can be queued in when piped pulls are enabled\&. If the queue reaches the specified limit, no new pull requests can be submitted until responses arrive, draining the queue somewhat\&.
.PP
\fBParameters\fP
.RS 4
\fIn\fP The maximum number of pull requests that can be queued\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE if the argument was valid, and the queue size was set to it, otherwise FALSE 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int smaxSync (\fBXSyncPoint\fP * sync, int timeoutMillis)"
Waits for the queue to reach the specified sync point, up to an optional timeout limit\&.
.PP
\fBParameters\fP
.RS 4
\fIsync\fP Pointer to a queued synchronization point\&. 
.br
\fItimeoutMillis\fP An optional timeout in milliseconds\&. When set to a positive value The call will be guaranteed to return in the specified interval, whether or not the pipelined reads all succeeded\&. The return value can be used to check for errors or if the call timed out before all data were collected\&. If X_TIMEDOUT is returned, smax_end_bulk_pulls() may be called again to allow more time for the queued read operations to complete\&. 0 or negative timeout values will cause the call to wait indefinitely until reads are complete\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if all reads have completed successfully, or the first read error that was enountered (e\&.g\&. RM_INVALID_KEY), or: X_TIMEDOUT if the call timed out while still awaiting data for the queued read requests\&. X_NULL if the SyncPoint argument is NULL, or its mutex/condition field have not been initialized\&. X_FAILURE if the SyncPoint's mutex has not been initialized\&.
.RE
.PP
or the first pull error encountered in the queue since the current batch began\&.
.PP
\fBSee also\fP
.RS 4
\fBsmaxCreateSyncPoint()\fP 
.PP
\fBsmaxWaitQueueComplete()\fP 
.RE
.PP

.PP
References \fBXSyncPoint::isComplete\fP, \fBXSyncPoint::lock\fP, \fBXSyncPoint::status\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_INCOMPLETE\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, \fBX_TIMEDOUT\fP, \fBx_trace()\fP, and \fBxvprintf\fP\&.
.SS "int smaxWaitQueueComplete (int timeoutMillis)"
Waits until all queued pull requests have been retrieved from the database, or until the specified timeout it reached\&.
.PP
\fBParameters\fP
.RS 4
\fItimeoutMillis\fP An optional timeout in milliseconds\&. When set to a positive value The call will be guaranteed to return in the specified interval, whether or not the pipelined reads all succeeded\&. The return value can be used to check for errors or if the call timed out before all data were collected\&. If X_TIMEDOUT is returned, smax_end_bulk_pulls() may be called again to allow more time for the queued read operations to complete\&. 0 or negative timeout values will cause the call to wait indefinitely until reads are complete\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if all reads have completed successfully, or the first read error that was enountered (e\&.g\&. RM_INVALID_KEY), or: X_TIMEDOUT if the call timed out while still awaiting data for the queued read requests\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBsmaxSync()\fP 
.RE
.PP

.PP
References \fBXSyncPoint::isComplete\fP, \fBXSyncPoint::lock\fP, \fBsmaxSync()\fP, \fBXSyncPoint::status\fP, \fBX_INCOMPLETE\fP, and \fBX_SUCCESS\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for smax-clib from the source code\&.
